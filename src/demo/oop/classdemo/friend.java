package demo.oop.classdemo;



/*练习继承，
    【super使用的注意的地方】
            1. 用super调用父类构造方法，必须是构造方法中的第一个语句。
            2. super只能出现在子类的方法或者构造方法中。
            3. super 和 this 不能够同时调用构造方法。（因为this也是在构造方法的第一个语句）
   方法的重写（override）
1. 方法重写只存在于子类和父类(包括直接父类和间接父类)之间。在同一个类中方法只能被重载，不
能被重写.
2. 静态方法不能重写
1. 父类的静态方法不能被子类重写为非静态方法 //编译出错
2. 父类的非静态方法不能被子类重写为静态方法；//编译出错
3. 子类可以定义与父类的静态方法同名的静态方法(但是这个不是覆盖)

1. 私有方法不能被子类重写，子类继承父类后,是不能直接访问父类中的私有方法的,那么就更谈不上
重写了。

1. 重写的语法
1. 方法名必须相同
2. 参数列表必须相同
3. 访问控制修饰符可以被扩大,但是不能被缩小： public protected default private
4. 抛出异常类型的范围可以被缩小,但是不能被扩大
ClassNotFoundException ---> Exception
5. 返回类型可以相同,也可以不同,如果不同的话,子类重写后的方法返回类型必须是父类方法返回
类型的子类型
例如：父类方法的返回类型是Person,子类重写后的返回类可以是Person也可以是Person的
子类型
注：一般情况下,重写的方法会和父类中的方法的声明完全保持一致,只有方法的实现不同。(也就是大括
号中代码不一样，其余一样)

为什么要重写？
子类继承父类,继承了父类中的方法,但是父类中的方法并不一定能满足子类中的功能需要,所以子类中需
要把方法进行重写。
1. 总结：
方法重写的时候，必须存在继承关系。
方法重写的时候，方法名和形式参数 必须跟父类是一致的。
方法重写的时候，子类的权限修饰符必须要大于或者等于父类的权限修饰符。( private < protected <
public，friendly < public )
方法重写的时候，子类的返回值类型必须小于或者等于父类的返回值类型。( 子类 < 父类 ) 数据类型没有
明确的上下级关系
方法重写的时候，子类的异常类型要小于或者等于父类的异常类型。

new一个对象时的初始化顺序：
1.父类static （static方法与其他方法的不同在于static只调用一次，其他方法是调用几次就有几次）
2.子类static
3.父类普通方法
4.父类无参构造方法
5.子类普通方法
6.子类无参构造方法
 */
public class friend extends Person {
@Override
    public void say(){
        System.out.println("friend类在叫");
    }

}
